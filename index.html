<!DOCTYPE html>
<!--suppress ALL -->
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Visual Summary of a Data Set</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="css/dc.css">
    <link rel="stylesheet" type="text/css" href="css/bootstrap.css">
    <link rel="stylesheet" type="text/css" href="css/main.css">
</head>
<body>
<div class="container-fluid">
    <div class="row">
        <div class="col-xs-12 dc-data-count" id="data-count">
            <h2>
                <small>
                    <span class="filter-count"></span> selected out of <span class="total-count"></span> records |
                    <a id="all" href="#">Reset All</a>
                </small>
            </h2>
        </div>
    </div>
    <div id="histograms">

        <!--<div class="col-xs-2">
            <div id="chart0-histogram">
                <a class="reset" href="#" onclick="histogramChart[0].filterAll();dc.redrawAll();" style="visibility: hidden;">reset</a>
                <span class="reset" style="visibility: hidden;"><span class="filter"></span></span>
            </div>
        </div>-->

    </div>
    <div class="row">
        <div class="col-xs-12">
            <table class="table table-bordered table-striped" id="data-table">

            </table>
        </div>
    </div>
</div>
<script type="text/javascript" src="js/d3.js"></script>
<script type="text/javascript" src="js/crossfilter.js"></script>
<script type="text/javascript" src="js/dc.js"></script>
<script type="text/javascript" src="js/underscore-min.js"></script>
<script type="text/javascript" src="js/jquery-1.12.3.js"></script>
<script type="text/javascript">

    // TODO only use if composite chart is used
    /* composite chart bug: brushing not applied
    bugfix from https://groups.google.com/forum/#!topic/dc-js-user-group/yI6_cbvgfbU
    edit the dc.js chart.brushing function */
    (function() {
        var compositeChart = dc.compositeChart;
        dc.compositeChart = function(parent, chartGroup) {
            var _chart = compositeChart(parent, chartGroup);

            _chart._brushing = function () {
                var extent = _chart.extendBrush();
                var rangedFilter = null;
                if(!_chart.brushIsEmpty(extent)) {
                    rangedFilter = dc.filters.RangedFilter(extent[0], extent[1]);
                }

                dc.events.trigger(function () {
                    if (!rangedFilter) {
                        _chart.filter(null);
                    } else {
                        _chart.replaceFilter(rangedFilter);
                    }
                    _chart.redrawGroup();
                }, dc.constants.EVENT_DELAY);
            };

            return _chart;
        };
    })();


    // global variables
    // the data from the csv-file
    var csv;
    // the column-names of the csv-file
    var csvColumnsNames = [];
    // the datatypes per colum of the csv-file
    var csvColumnsDatatypes = [];
    // the crossfilter from our csv-file => used for brusing and linking
    var ndx;
    // dimension for the table, with the whole csv as dimension
    var allDim;
    // all histogramcharts
    var histogramCharts = [];
    // url
    var url = 'data/P16TAbs3.csv';

    // TODO File selector / Dragndrop
    // when the document is ready (dom loaded), start with the parsing and chart-generating
    $().ready(function () {
        $.get(url)
                .done(function (data) {
                    console.log("URL fetched");
                    // correct ';' to ',' (';' is often used in german csv-files as delimiter)
                    csv = d3.csv.parseRows(data.replace(/\s*;\s*/g, ","));
                    console.log(csv);
                    parseCSVData();
                    generateCharts();
                })
                .fail(function (xhr) {
                    console.log("URL fetch failed.");
                });
    });


    /**
     * parse the csv-file, extract the column names, try to get the column-datatypes
     * (first row is expected to be the header row)
     */
    function parseCSVData() {
        var datatypes_per_column = [];

        const regexp_int = /^[\-]{0,1}[0-9]+$/;
        const regexp_double = /^[\-]{0,1}[0-9]+[\.|,][0-9]+$/;
        const regexp_boolean = /^(0|1|(true)|false){1}$/;

        /* now we have an array with many arrays in it (all the rows from the csv).
         first, find the head-row, and the datatypes of the different columns.
         head row: the head row can be the first row of the document, but sometimes it's the second row, or it doesn't exist.
         datatype: iterate over the array, pick the datatype, which occurs the most.*/
        for (var i = 0; i < csv.length; i++) {

            for (var m = 0; m < Math.min(csv[m].length, csv[0].length); m++) {
                var cell = csv[i][m];

                if (i == 0) {
                    datatypes_per_column[m] = {"empty_count": 0, "int_count": 0, "double_count": 0, "boolean_count": 0};
                    csvColumnsNames[m] = cell;
                    continue; // because we don't want to count the header-row
                }

                if (cell.trim() === "" || cell.trim() === "-") {
                    datatypes_per_column[m].empty_count++;
                }
                if ((regexp_int.exec(cell)) !== null) {
                    datatypes_per_column[m].int_count++;
                }
                if ((regexp_double.exec(cell)) !== null) {
                    datatypes_per_column[m].double_count++;
                }
                if ((regexp_boolean.exec(cell)) !== null) {
                    datatypes_per_column[m].boolean_count++;
                }
            }
        }
        console.log(datatypes_per_column);

        // delete the first row of the csv (header)
        csv = deleteRow(csv, 0);
        console.log(csvColumnsNames);
        console.log(csv);


        // check results, set the data type of the row
        var col_datatype_index = 0;
        const number_of_rows = csv.length;

        for (var i = 0; i < datatypes_per_column.length; i++) {
            csvColumnsDatatypes[col_datatype_index++] = "string";
            const number_of_non_empty_cells = number_of_rows - datatypes_per_column[i].empty_count;
            const datatype_treshold = number_of_non_empty_cells * 0.8;
            // TODO numbers fiddling

            if (datatypes_per_column[i].int_count >= datatype_treshold) {
                if (datatypes_per_column[i].double_count >= number_of_non_empty_cells * 0.1) {
                    csvColumnsDatatypes[col_datatype_index - 1] = "double";
                } else {
                    csvColumnsDatatypes[col_datatype_index - 1] = "int";
                }
            } else if (datatypes_per_column[i].double_count >= datatype_treshold) {
                csvColumnsDatatypes[col_datatype_index - 1] = "double";
            }
            if (datatypes_per_column[i].boolean_count >= datatype_treshold) {
                csvColumnsDatatypes[col_datatype_index - 1] = "boolean";
            }

            // change data types of the values
            if (csvColumnsDatatypes[col_datatype_index - 1] != "string") {
                for (var m = 0; m < csv.length; m++) {
                    // change to int and double values from string
                    if (csvColumnsDatatypes[col_datatype_index - 1] === "int" || csvColumnsDatatypes[col_datatype_index - 1] === "double") {
                        csv[m][i] = +csv[m][i];
                    } else { // boolean
                        // TODO Change TODO markieren von veränderten werten/ markieren von else werten (falsche werte, eg 2, 3, asdf)
                        if (csv[m][i] === "0" || csv[m][i].trim() === "false") {
                            csv[m][i] = false;
                        } else if (csv[m][i] === "1" || csv[m][i].trim() === "true") {
                            csv[m][i] = true;
                        }
                    }
                }
            }
        }
        console.log(csvColumnsDatatypes);

        // prepend is used for inserting content at the beginning of an element
        // substring from after the last slash until the end
        // TODO show number of columns and rows
        $(".dc-data-count").children("h2").prepend(url.substring(url.lastIndexOf("/") + 1));
    }


    /**
     * creates charts (histograms for all columns) and other important charts TODO
     */
    function generateCharts() {
        // set crossfilter, set allDim (used for the table)
        ndx = crossfilter(csv);
        allDim = ndx.dimension(function (d) { return d; });

        // create histograms for all columns
         for (var i = 0; i < csvColumnsNames.length; i++) {
             createHistogramPlot(i);
         }
        //createHistogramPlot(0);

        // collect important data for all columns
        // number of rows and columns, format of each column (string, double, etc.), deviation of values of numerical columns, length of strings, etc.
        for (var i = 0; i < csvColumnsNames.length; i++) {
            calculateColumnStats(i);
        }

        // create covariance matrix
        // TODO

        // create multivarate/interesting plots
        // TODO

        // create the datatable
        createDataTable();

        // render all the charts
        dc.renderAll();
    }


    /**
     *
     */
    function calculateColumnStats (index) {
        if (csvColumnsDatatypes[index] === "int" || csvColumnsDatatypes[index] === "double") { // int or double
            /* interesting values for int or double columns:
             1. average / robust average (median zb)
             2. scattering / robust scattering (IQR zb)
             3. % ausreißer / % leer
             4. min/max value
             5. #unique values
             6. quantile
             7. boxplot optional*/

        } else {
            /* interesting values for boolean or string columns:
             1. avg-string länge
             2. min/max string länge
             3. % leer
             4. #unique values
             5.
             */
        }
    }

    var elemsInHistogramRow = Infinity;
    /**
     * creates a histogram, from the column [index] of the csv-file
     * no return value needed, dc.barchart is initialized
     * @param {number} index
     */
    function createHistogramPlot (index) {
        // create dimension & grouping (x- & y-values)
        var histogramDimension;
        var histogramGrouping;

        // init chart & table
        // structure to create:
        // <div class="col-xs-2">
        //  <div id="chartX-histogram">
        //   <a class="reset" href="#" onclick="histogramCharts[X].filterAll();dc.redrawAll();" style="display: none;">reset</a>
        //   <span class="reset" style="display: none;"><span class="filter"></span></span>

        var chartDivId = "chart" + index + "-histogram";
        // TODO dynamische zuweisung funktioniert nicht, produziert fehler
        // => http://stackoverflow.com/questions/32973616/uncaught-typeerror-cannot-read-property-textcontent-of-null-error
        console.log(elemsInHistogramRow);
        if (elemsInHistogramRow >= 4) {
            var rowDiv = d3.select("#histograms").append("div")
                    .attr("class", "row");
            elemsInHistogramRow = 0;
            console.log("DRIN");

        }
        var columnDiv = d3.select("#histograms>div:last-child").append("div")
                .attr("class", "col-xs-6 col-md-3");
        elemsInHistogramRow++;
        var chartDiv = columnDiv.append("div")
                .attr("id", chartDivId)
                .attr("class", "dc-chart");
        chartDiv.append("a")
                .attr("class", "reset")
                .attr("href", "#")
                .attr("onclick", "histogramCharts[" + index + "].filterAll();dc.redrawAll();")
                .attr("style" , "display:none");
        var resetSpan = chartDiv.append("span")
                .attr("class", "reset")
                .attr("style", "display:none");
        resetSpan.append("span")
                .attr("class", "filter");

        histogramCharts[index] = dc.barChart("#" + chartDivId);

        // check datatype of column, react accordingly
        if (csvColumnsDatatypes[index] === "int" || csvColumnsDatatypes[index] === "double") { // int or double
            // get the minimum and maximum value from the column
            // get the bin width (max - min) / 10
            // add half a bin to the lower and upper end
            // in the end, we have 11 bins
            var arrayMinValue = arrayMin(csv, index);
            var arrayMaxValue = arrayMax(csv, index)
            var histogramBinWidth = Math.round((arrayMaxValue - arrayMinValue) / 10);
            var histogramRange = [arrayMin(csv, index) - histogramBinWidth/2, arrayMax(csv, index) + histogramBinWidth/2];
            console.log("low: " + histogramRange[0]);
            console.log("high: " + histogramRange[1]);
            console.log("width: " + histogramBinWidth);

            // dimension = x-axis values => ranges
            histogramDimension = ndx.dimension(function(d) {
                var histogramValue = d[index];
                /*if (histogramThresholded <= histogramRange[0]) histogramThresholded = histogramRange[0];
                 if (histogramThresholded > histogramRange[1]) histogramThresholded = histogramRange[1] - histogramBinWidth;*/
                return histogramRange[0] + (Math.floor((histogramValue - histogramRange[0]) / histogramBinWidth) * histogramBinWidth);
            });

            // grouping = y-axis values => items grouped by histogram-parts, how many items per histogram-part?
            histogramGrouping = histogramDimension.group(); // by default reduceCount

            // TODO IF ELSE code duplicate
            // fill chart
            histogramCharts[index]
                    .width(300)
                    .height(180)
                    .margins({top: 10, right: 20, bottom: 50, left: 50})
                    .centerBar(false)
                    .elasticY(true)
                    .dimension(histogramDimension)
                    .group(histogramGrouping)
                    .colors("#C11E1C")
                    .x(d3.scale.linear().domain(histogramRange))
                    .xUnits(dc.units.fp.precision(histogramBinWidth)) // x-axis precision = binWidth
                    .round(function(d) { // with this command, only whole columns can be selected
                        return histogramRange[0] + (Math.round((d - histogramRange[0]) / histogramBinWidth) * histogramBinWidth);
                    })
                    .renderHorizontalGridLines(true)
                    .xAxisLabel(csvColumnsNames[index])
                    .yAxisLabel('numberns')
                    .brushOn(true);


            // axis formatting https://github.com/mbostock/d3/wiki/Formatting
            // "d" = integer
            // 6 ticks @ y-axis
            var xAxis_histogramChart = histogramCharts[index].xAxis();
            xAxis_histogramChart.ticks(6).tickFormat(d3.format("d"));
            var yAxis_histogramChart = histogramCharts[index].yAxis();
            yAxis_histogramChart.ticks(6).tickFormat(d3.format("d")).tickSubdivide(0); // tickSubdivide(0) should remove sub ticks but not

        } else { // boolean or string => ordinal scale instead of linear scale
            // dimension = x-axis values => ranges
            if (csvColumnsDatatypes[index] === "boolean") {
                histogramDimension = ndx.dimension(function (d) {
                    console.log( d[index]);
                    if (d[index] != true && d[index] != false) {
                        return "?"
                    }
                    else {
                        return d[index]
                    };
                });
            } else {
                histogramDimension = ndx.dimension(function (d) { console.log( d[index]); return d[index]; });
            }

            // grouping = y-axis values => items grouped by histogram-parts, how many items per histogram-part?
            histogramGrouping = histogramDimension.group(); // by default reduceCount

            // fill chart
            histogramCharts[index]
                    .width(300)
                    .height(180)
                    .margins({top: 10, right: 20, bottom: 50, left: 50})
                    .centerBar(false)
                    .elasticY(true)
                    .dimension(histogramDimension)
                    .group(histogramGrouping)
                    .colors("#C11E1C")
                    .x(d3.scale.ordinal()) // ordinal scala
                    .xUnits(dc.units.ordinal)
                    .renderHorizontalGridLines(true)
                    .xAxisLabel(csvColumnsNames[index])
                    .yAxisLabel('numoins')
                    .ordering(function(d) { return -d.value; }) // order descending http://stackoverflow.com/questions/25204782/sorting-ordering-the-bars-in-a-bar-chart-by-the-bar-values-with-dc-js
                    .brushOn(true);


            // axis formatting https://github.com/mbostock/d3/wiki/Formatting
            // "d" = integer
            // 6 ticks @ y-axis
            var xAxis_histogramChart = histogramCharts[index].xAxis();
            xAxis_histogramChart.tickFormat(function(v) { return ""; }); // we don't want axis-text, because the text is overlapping, and thus looks very bad
            var yAxis_histogramChart = histogramCharts[index].yAxis();
            yAxis_histogramChart.ticks(6).tickFormat(d3.format("d")).tickSubdivide(0); // tickSubdivide(0) should remove sub ticks but not

        }
    }


    /**
     * creates a data table, with full data
     * brushing and linking is enabled
     */
    function createDataTable() {
        // init the table
        var dataTable = dc.dataTable("#data-table");

        // create an array for the columns, consisting of label, format
        var columnarray = [];
        for (var i = 0; i < csv[0].length; i++) {
            columnarray[i] = "" + i;
        }

        // fill the table
        dataTable
                .dimension(allDim)
                .group(function (d) {
                    return 'dc.js insists on putting a row here so I remove it using JS';
                })
                .size(100)
                .columns(columnarray)
                .sortBy(dc.pluck('0')) // sort by the values of the first column
                //.order(d3.descending)
                .on('renderlet', function (table) {
                    // each time table is rendered remove nasty extra row dc.js insists on adding
                    table.select('tr.dc-table-group').remove();
                    // change the header
                    var thElements = $('#data-table').children('th');
                    for (var i = 0; i < thElements.length; i++) {
                        thElements[i].firstChild.nodeValue = csvColumnsNames[i];
                    }
                });


        // TODO: on renderlet formatting of the table: http://stackoverflow.com/questions/26657621/dc-js-datatable-custom-formatting => outliers, missing values etc
        // maybe also relevant: http://stackoverflow.com/questions/25083383/custom-text-filter-for-dc-js-datatable (custom text filter for a dc.js table)
    }


    /**
     * deletes the row with rownumber [row] from the [array]
     * used eg. for deleting the first row (header), after extracting the data from it
     * @param {array} array
     * @param {number} row
     * @returns {array}
     */
    function deleteRow(array, row) {
        array = array.slice(0); // make copy
        array.splice(row, 1);
        return array;
    }


    /**
     * find the minimum value from the column [index] of the [array]
     * @param {array} array
     * @param {number} index
     * @returns {number}
     */
    function arrayMin(array, index) {
        var min = Infinity;
        for (var i = 0; i < array.length; i++) {
            if (array[i][index] < min) {
                min = array[i][index];
            }
        }
        return min;
    }


    /**
     * find the maximum value from the column [index] of the [array]
     * @param {array} array
     * @param {number} index
     * @returns {number}
     */
    function arrayMax(array, index) {
        var max = -Infinity;
        for (var i = 0; i < array.length; i++) {
            if (array[i][index] > max) {
                max = array[i][index];
            }
        }
        return max;
    }
</script>
</body>
</html>
